--- vboxdrv/r0drv/linux/memobj-r0drv-linux.c.orig	2016-12-29 10:01:02.871956809 -0500
+++ vboxdrv/r0drv/linux/memobj-r0drv-linux.c	2016-12-29 10:14:29.412918098 -0500
@@ -578,7 +578,7 @@
                 {
                     if (!PageReserved(pMemLnx->apPages[iPage]))
                         SetPageDirty(pMemLnx->apPages[iPage]);
-                    page_cache_release(pMemLnx->apPages[iPage]);
+                    put_page(pMemLnx->apPages[iPage]);
                 }
 
                 if (pTask && pTask->mm)
@@ -1029,14 +1029,39 @@
         /*
          * Get user pages.
          */
-        rc = get_user_pages(pTask,                  /* Task for fault accounting. */
-                            pTask->mm,              /* Whose pages. */
-                            R3Ptr,                  /* Where from. */
-                            cPages,                 /* How many pages. */
-                            fWrite,                 /* Write to memory. */
-                            fWrite,                 /* force write access. */
-                            &pMemLnx->apPages[0],   /* Page array. */
-                            papVMAs);               /* vmas */
+        if (R0Process == RTR0ProcHandleSelf())
+            rc = get_user_pages(R3Ptr,                  /* Where from. */
+                                cPages,                 /* How many pages. */
+# if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0)
+                                fWrite ? FOLL_WRITE |   /* Write to memory. */
+                                         FOLL_FORCE     /* force write access. */
+                                       : 0,             /* Write to memory. */
+# else
+                                fWrite,                 /* Write to memory. */
+                                fWrite,                 /* force write access. */
+# endif
+                                &pMemLnx->apPages[0],   /* Page array. */
+                                papVMAs);               /* vmas */
+        /*
+         * Actually this should not happen at the moment as call this function
+         * only for our own process.
+         */
+       else
+            rc = get_user_pages_remote(
+                                pTask,                  /* Task for fault accounting. */
+                                pTask->mm,              /* Whose pages. */
+                                R3Ptr,                  /* Where from. */
+                                cPages,                 /* How many pages. */
+# if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0)
+                                fWrite ? FOLL_WRITE |   /* Write to memory. */
+                                         FOLL_FORCE     /* force write access. */
+                                       : 0,             /* Write to memory. */
+# else
+                                fWrite,                 /* Write to memory. */
+                                fWrite,                 /* force write access. */
+# endif
+                                &pMemLnx->apPages[0],   /* Page array. */
+                                papVMAs);         
         if (rc == cPages)
         {
             /*
@@ -1081,7 +1106,7 @@
         {
             if (!PageReserved(pMemLnx->apPages[rc]))
                 SetPageDirty(pMemLnx->apPages[rc]);
-            page_cache_release(pMemLnx->apPages[rc]);
+            put_page(pMemLnx->apPages[rc]);
         }
 
         up_read(&pTask->mm->mmap_sem);
